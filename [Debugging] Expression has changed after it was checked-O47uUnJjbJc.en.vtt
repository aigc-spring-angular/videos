WEBVTT
Kind: subtitles
Language: en

00:00:00.460 --> 00:00:01.960
SPEAKER: Expression
changed after it

00:00:01.960 --> 00:00:03.070
has been checked error.

00:00:03.070 --> 00:00:05.680
You'll encounter this error
if your code changes a value

00:00:05.680 --> 00:00:07.450
after change
detection has been run

00:00:07.450 --> 00:00:09.100
and the view has
been built. You'll

00:00:09.100 --> 00:00:10.630
only see this error
in development

00:00:10.630 --> 00:00:12.970
because Angular runs an
additional change detection

00:00:12.970 --> 00:00:14.860
check to catch
errors like this that

00:00:14.860 --> 00:00:16.600
can cause erratic UI behavior.

00:00:16.600 --> 00:00:18.700
The extra check ensures
the app is stable

00:00:18.700 --> 00:00:21.610
and that all data updates have
been reflected in the views.

00:00:21.610 --> 00:00:23.500
There are a variety
of reasons that view

00:00:23.500 --> 00:00:26.380
might be left in an inconsistent
state, such as code that

00:00:26.380 --> 00:00:29.230
updates the view during the
AfterViewInit lifecycle hook

00:00:29.230 --> 00:00:31.570
or when change detection
triggers itself

00:00:31.570 --> 00:00:33.400
in an infinite loop,
like a method that

00:00:33.400 --> 00:00:35.200
returns a different
value each time

00:00:35.200 --> 00:00:36.820
or a child component
that changes

00:00:36.820 --> 00:00:38.470
the bindings on its parent.

00:00:38.470 --> 00:00:40.690
Let's start by looking
at a simple reproduction

00:00:40.690 --> 00:00:41.590
and solution.

00:00:41.590 --> 00:00:43.960
Then we'll take a more detailed
look at Angular's change

00:00:43.960 --> 00:00:46.390
detection to understand
why this error happens

00:00:46.390 --> 00:00:47.770
and why it's important.

00:00:47.770 --> 00:00:49.300
Here in the app
component template,

00:00:49.300 --> 00:00:52.540
we're using the ngIf directive
with a loading Boolean.

00:00:52.540 --> 00:00:54.670
In the model or our
component type script,

00:00:54.670 --> 00:00:57.200
we give it a default
value of true.

00:00:57.200 --> 00:00:59.650
Then using the AfterViewInit
lifecycle hook,

00:00:59.650 --> 00:01:01.810
we flip the value to false
when it's done loading.

00:01:01.810 --> 00:01:03.190
But when we run
this code, we see

00:01:03.190 --> 00:01:05.650
expression changed after
it has been checked error.

00:01:05.650 --> 00:01:08.200
Previous value false,
current value true.

00:01:08.200 --> 00:01:10.300
Now, in a more complex
app, it might not

00:01:10.300 --> 00:01:12.520
be clear where this
error originates from.

00:01:12.520 --> 00:01:13.960
But you can always
assume that it

00:01:13.960 --> 00:01:16.420
has something to do with
a binding in the template.

00:01:16.420 --> 00:01:19.330
In the stack trace, you'll
find a link to the source map

00:01:19.330 --> 00:01:21.640
for the component template
that caused the error.

00:01:21.640 --> 00:01:23.650
And it takes us directly
to the line of code

00:01:23.650 --> 00:01:27.040
that caused the issue, which is
our ngIf binding to the loading

00:01:27.040 --> 00:01:27.730
Boolean.

00:01:27.730 --> 00:01:30.040
What the error is trying to
tell us is that the loading

00:01:30.040 --> 00:01:32.650
value has changed after
the change detection cycle

00:01:32.650 --> 00:01:33.370
has completed.

00:01:33.370 --> 00:01:35.810
But what exactly is wrong
with our code in this case?

00:01:35.810 --> 00:01:38.590
The short answer is that we're
using the wrong lifecycle hook.

00:01:38.590 --> 00:01:41.650
If we move our code from
AfterViewInit to OnInit,

00:01:41.650 --> 00:01:44.290
the error goes away and
everything works perfectly.

00:01:44.290 --> 00:01:46.750
In other words, if you find
yourself updating values

00:01:46.750 --> 00:01:48.760
in AfterViewInit,
there's a good chance

00:01:48.760 --> 00:01:52.000
that a simple refactor to OnInit
or the component constructor

00:01:52.000 --> 00:01:53.980
will fix the issue.

00:01:53.980 --> 00:01:56.440
OK, at this point, we know we
used the wrong lifecycle hook

00:01:56.440 --> 00:01:58.360
and we can fix it
by refactoring.

00:01:58.360 --> 00:02:00.220
But to really
understand why, let's

00:02:00.220 --> 00:02:03.220
do a quick review of how change
detection works in Angular.

00:02:03.220 --> 00:02:05.170
The goal of change
detection is to keep

00:02:05.170 --> 00:02:07.540
the model, your type
script code, in sync

00:02:07.540 --> 00:02:09.340
with the template, your HTML.

00:02:09.340 --> 00:02:12.040
And it does so by looking for
data changes in the component

00:02:12.040 --> 00:02:13.490
tree from top to bottom.

00:02:13.490 --> 00:02:16.450
First it checks the parent, then
the first child, second child,

00:02:16.450 --> 00:02:17.270
and so on.

00:02:17.270 --> 00:02:19.240
But if we update a
binding on the parent

00:02:19.240 --> 00:02:20.740
after it has already
been checked,

00:02:20.740 --> 00:02:22.820
Angular will throw the error.

00:02:22.820 --> 00:02:25.330
Now, what we have here
is a simplified breakdown

00:02:25.330 --> 00:02:27.430
of Angular's
lifecycle or the steps

00:02:27.430 --> 00:02:30.010
it performs when a component
is first initialized.

00:02:30.010 --> 00:02:33.160
First it updates the bindings
like the ngIf directive

00:02:33.160 --> 00:02:34.030
and the template.

00:02:34.030 --> 00:02:36.730
Then it runs the OnInit
lifecycle hook, updates

00:02:36.730 --> 00:02:39.170
the dom, then runs change
detection for the child

00:02:39.170 --> 00:02:39.670
component.

00:02:39.670 --> 00:02:42.070
Notice how the final
step is AfterViewInit,

00:02:42.070 --> 00:02:45.040
and more importantly, that it
runs after change detection.

00:02:45.040 --> 00:02:46.900
Basically, any
code that runs here

00:02:46.900 --> 00:02:48.580
should not attempt
to update the view.

00:02:48.580 --> 00:02:51.190
And that was the root of
the problem in this case.

00:02:51.190 --> 00:02:54.500
Refactoring to OnInit works
great for initial values.

00:02:54.500 --> 00:02:55.983
But if that doesn't
fix the issue,

00:02:55.983 --> 00:02:57.400
there are a few
other ways you may

00:02:57.400 --> 00:02:59.650
have encountered this error
along with additional ways

00:02:59.650 --> 00:03:00.220
to fix it.

00:03:00.220 --> 00:03:02.980
In the component here, we're
using ViewChild to grab

00:03:02.980 --> 00:03:04.210
an element from the dom.

00:03:04.210 --> 00:03:05.950
But this element
won't be available

00:03:05.950 --> 00:03:08.530
until the AfterViewInit
lifecycle hook is called.

00:03:08.530 --> 00:03:10.870
But what if we can't update
the state of the component

00:03:10.870 --> 00:03:13.150
until after we have
the ViewChild element?

00:03:13.150 --> 00:03:15.130
If we can't refactor
to ngOnInit,

00:03:15.130 --> 00:03:16.810
we have a couple
of other options.

00:03:16.810 --> 00:03:19.360
An approach you'll often see
on Stack Overflow answers

00:03:19.360 --> 00:03:21.520
is to make the
update asynchronous.

00:03:21.520 --> 00:03:23.350
When we make the
update async, it'll

00:03:23.350 --> 00:03:25.600
be picked up on the next
change detection check

00:03:25.600 --> 00:03:27.470
and prevent the
error from occurring.

00:03:27.470 --> 00:03:29.950
We can make it asynchronous
by wrapping it in a set

00:03:29.950 --> 00:03:31.720
timeout with a delay of 0.

00:03:31.720 --> 00:03:34.300
That'll put the update in
the next macro task queue

00:03:34.300 --> 00:03:35.740
of the JavaScript event loop.

00:03:35.740 --> 00:03:37.690
Alternatively, we
can use a promise

00:03:37.690 --> 00:03:40.960
that resolves immediately then
run the update in its callback.

00:03:40.960 --> 00:03:42.610
This code will achieve
the same result.

00:03:42.610 --> 00:03:45.370
The only subtle difference is
that it runs on the microtask

00:03:45.370 --> 00:03:47.740
queue before the end of
the current iteration

00:03:47.740 --> 00:03:49.070
in the browser's event loop.

00:03:49.070 --> 00:03:50.920
Making the update
asynchronous can work,

00:03:50.920 --> 00:03:53.350
however it's very
implicit and should really

00:03:53.350 --> 00:03:55.330
only be used as a last resort.

00:03:55.330 --> 00:03:58.030
It's not clear why we make this
code asynchronous unless you

00:03:58.030 --> 00:04:00.800
understand the nuances of
Angular change detection

00:04:00.800 --> 00:04:02.020
and the browser's event loop.

00:04:02.020 --> 00:04:05.110
Luckily, Angular provides us
with a more direct and explicit

00:04:05.110 --> 00:04:06.640
way to trigger change detection.

00:04:06.640 --> 00:04:09.580
We can manually trigger it by
injecting the change detector

00:04:09.580 --> 00:04:11.740
ref in the constructor
of the component.

00:04:11.740 --> 00:04:15.070
We can then use it to manually
run change detection by calling

00:04:15.070 --> 00:04:16.610
the detectChanges method.

00:04:16.610 --> 00:04:19.037
This will tell Angular to
check the view and its children

00:04:19.037 --> 00:04:21.370
in which case, it will notice
that our loading state has

00:04:21.370 --> 00:04:24.228
changed, giving us yet another
way to address the error.

00:04:24.228 --> 00:04:26.770
Now, an entirely different way
you might encounter this error

00:04:26.770 --> 00:04:28.480
is when you have
a method, usually

00:04:28.480 --> 00:04:31.340
a getter, that doesn't
return a predictable value,

00:04:31.340 --> 00:04:33.670
which can cause an infinite
change detection loop.

00:04:33.670 --> 00:04:36.070
Take for example this
getter in our component that

00:04:36.070 --> 00:04:37.460
returns a random number.

00:04:37.460 --> 00:04:39.310
If we try to use this
value in the template,

00:04:39.310 --> 00:04:42.190
Angular will get a different
value each time it's checked.

00:04:42.190 --> 00:04:43.990
The solution in
this case is to make

00:04:43.990 --> 00:04:46.180
the method return a
consistent value based

00:04:46.180 --> 00:04:47.660
on the state of the component.

00:04:47.660 --> 00:04:50.020
In other words, getters
should be derived directly

00:04:50.020 --> 00:04:52.180
from the component state
and not values that change

00:04:52.180 --> 00:04:54.910
constantly like timestamps
or random numbers.

00:04:54.910 --> 00:04:56.410
Now let's take a
look at one more

00:04:56.410 --> 00:04:59.470
example where we have both
a parent and child component

00:04:59.470 --> 00:05:00.430
at play.

00:05:00.430 --> 00:05:03.340
The app component, the parent,
contains the loading state,

00:05:03.340 --> 00:05:05.048
just like our previous examples.

00:05:05.048 --> 00:05:07.090
But instead of running
the update from the parent

00:05:07.090 --> 00:05:09.730
component, we'll make it
happen from a child component

00:05:09.730 --> 00:05:11.020
with a custom event.

00:05:11.020 --> 00:05:13.030
In the item
component, the child,

00:05:13.030 --> 00:05:16.450
we're using the output decorator
to create a custom event along

00:05:16.450 --> 00:05:17.780
with an event emitter.

00:05:17.780 --> 00:05:20.800
Then during ngOnInit, we'll
go ahead and emit the event

00:05:20.800 --> 00:05:22.310
with a value of true.

00:05:22.310 --> 00:05:24.220
Then back in the app
component template,

00:05:24.220 --> 00:05:26.650
we'll go ahead and declare
the item component.

00:05:26.650 --> 00:05:29.590
When it fires, we'll set
the loading value to false.

00:05:29.590 --> 00:05:31.480
The end result is
a situation where

00:05:31.480 --> 00:05:33.700
we have a child component
updating the parent

00:05:33.700 --> 00:05:36.220
after change detection has
already run on the parent.

00:05:36.220 --> 00:05:38.260
And once again, that
produces the error.

00:05:38.260 --> 00:05:39.880
A potential solution
in this case

00:05:39.880 --> 00:05:42.940
would be to move the loading
state into the child component.

00:05:42.940 --> 00:05:44.620
And if that's not
possible, you might

00:05:44.620 --> 00:05:46.960
consider moving the
state to a shared service

00:05:46.960 --> 00:05:49.450
where it can be ejected
in multiple components.

00:05:49.450 --> 00:05:51.580
Let's finish up by
doing a quick recap.

00:05:51.580 --> 00:05:53.290
The expression
changed after it has

00:05:53.290 --> 00:05:56.740
been checked error occurs
because a value in the template

00:05:56.740 --> 00:05:59.920
has been updated after change
detection has finished.

00:05:59.920 --> 00:06:02.680
Debug it by first finding the
template in the stack trace.

00:06:02.680 --> 00:06:04.300
From there you can
analyze your code

00:06:04.300 --> 00:06:06.220
to determine where the
value is being updated

00:06:06.220 --> 00:06:08.220
and use one of the methods
covered in this video

00:06:08.220 --> 00:06:10.840
to address it, such as
refactoring to the OnInit

00:06:10.840 --> 00:06:12.970
lifecycle hook, using
ChangeDetectorRef

00:06:12.970 --> 00:06:15.310
manually, making
getters idempotent,

00:06:15.310 --> 00:06:18.250
or making your updates
async as a last resort.

00:06:18.250 --> 00:06:19.990
Refer to the Angular
documentation

00:06:19.990 --> 00:06:22.500
for additional
details and examples.

