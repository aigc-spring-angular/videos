WEBVTT
Kind: subtitles
Language: en

00:00:00.000 --> 00:00:02.700
SPEAKER: "Circular
dependency in DI detected."

00:00:02.700 --> 00:00:04.200
You'll encounter
this error when you

00:00:04.200 --> 00:00:07.500
have a dependency that depends
on itself, either directly

00:00:07.500 --> 00:00:09.330
or, more often, indirectly.

00:00:09.330 --> 00:00:12.090
A runtime error will be thrown
in the browser console telling

00:00:12.090 --> 00:00:13.440
you which class is affected.

00:00:13.440 --> 00:00:15.150
But what's perhaps
more useful is

00:00:15.150 --> 00:00:17.520
a warning that can be
seen both in the console

00:00:17.520 --> 00:00:18.510
and in the terminal.

00:00:18.510 --> 00:00:20.520
Most importantly,
it provides the path

00:00:20.520 --> 00:00:21.900
of the circular dependency.

00:00:21.900 --> 00:00:23.730
If we look closely,
it's telling us

00:00:23.730 --> 00:00:25.770
we have a storage
class that injects

00:00:25.770 --> 00:00:29.010
a user class, which itself
depends on the original storage

00:00:29.010 --> 00:00:29.640
class.

00:00:29.640 --> 00:00:31.740
Let's go ahead and look
at a simple reproduction,

00:00:31.740 --> 00:00:34.290
and then we'll take some time
to go in-depth about Angular's

00:00:34.290 --> 00:00:35.748
dependency injection system.

00:00:35.748 --> 00:00:37.290
If we take a look
at our source code,

00:00:37.290 --> 00:00:40.620
you'll notice we have two
services, user and storage.

00:00:40.620 --> 00:00:42.810
The problem is that
user has injected

00:00:42.810 --> 00:00:45.030
storage in its
constructor and storage

00:00:45.030 --> 00:00:47.100
has injected user
in its constructor,

00:00:47.100 --> 00:00:50.010
putting them in an impossible
codependent relationship.

00:00:50.010 --> 00:00:52.110
The solution to this
problem is to break

00:00:52.110 --> 00:00:54.930
the loop, which will most
likely require some refactoring.

00:00:54.930 --> 00:00:56.880
It's perfectly OK
for an injectable

00:00:56.880 --> 00:01:00.090
to depend on another injectable,
but the relationship can only

00:01:00.090 --> 00:01:02.050
go one way, which
means in this case,

00:01:02.050 --> 00:01:04.590
we need to refactor to
remove the user service

00:01:04.590 --> 00:01:06.510
from storage, or vice versa--

00:01:06.510 --> 00:01:08.640
remove the storage
service from user.

00:01:08.640 --> 00:01:10.800
And generally speaking,
it's a good idea

00:01:10.800 --> 00:01:12.630
to minimize the
number of dependencies

00:01:12.630 --> 00:01:14.550
in an injectable
service because that

00:01:14.550 --> 00:01:16.650
will reduce the likelihood
of similar issues

00:01:16.650 --> 00:01:17.830
coming up in the future.

00:01:17.830 --> 00:01:20.070
Now, in our storage
class, we have a method

00:01:20.070 --> 00:01:21.990
to write the user
to the database,

00:01:21.990 --> 00:01:24.570
but it depends on the user
service for the current user

00:01:24.570 --> 00:01:25.140
value.

00:01:25.140 --> 00:01:28.080
We can address the problem
here by refactoring our code

00:01:28.080 --> 00:01:30.540
to take the user
value as an argument

00:01:30.540 --> 00:01:32.850
rather than inject
the entire user class.

00:01:32.850 --> 00:01:35.100
Not only does that allow
us to remove the dependency

00:01:35.100 --> 00:01:37.680
from the constructor, it will
also make this code easier

00:01:37.680 --> 00:01:40.260
to unit test because you don't
have an additional dependency

00:01:40.260 --> 00:01:41.820
to mock or worry about.

00:01:41.820 --> 00:01:44.460
And the method only depends
on its input arguments,

00:01:44.460 --> 00:01:46.350
making it easier
to reason about.

00:01:46.350 --> 00:01:49.470
Now, if we go ahead and save
our changes, the error is gone.

00:01:49.470 --> 00:01:51.360
But before we wrap
things up, let's

00:01:51.360 --> 00:01:53.910
take a deeper look at
Angular's dependency injection

00:01:53.910 --> 00:01:56.640
to understand why this error
happens in the first place.

00:01:56.640 --> 00:01:59.190
When you generate a service
with the Angular CLI,

00:01:59.190 --> 00:02:01.980
you'll notice how the class
is decorated with injectable.

00:02:01.980 --> 00:02:04.200
When used with the
provided end root option,

00:02:04.200 --> 00:02:05.910
Angular will
instantiate the class

00:02:05.910 --> 00:02:08.520
and make it visible throughout
the entire application.

00:02:08.520 --> 00:02:11.820
Unlike a component, this class
is only instantiated once

00:02:11.820 --> 00:02:12.870
as a singleton.

00:02:12.870 --> 00:02:15.430
Now, imagine two classes
that depend on each other.

00:02:15.430 --> 00:02:17.850
How do you determine which
one to instantiate first?

00:02:17.850 --> 00:02:19.965
It's a classic "chicken
or the egg" paradox.

00:02:19.965 --> 00:02:22.590
And that just doesn't work when
you're following the dependency

00:02:22.590 --> 00:02:23.880
and version principle.

00:02:23.880 --> 00:02:25.210
Let's go ahead and recap.

00:02:25.210 --> 00:02:28.170
When you encounter "Circular
dependency and DI detected,"

00:02:28.170 --> 00:02:30.630
the first step is to determine
which dependencies create

00:02:30.630 --> 00:02:32.550
a loop by mapping
out the dependencies

00:02:32.550 --> 00:02:35.010
and the constructor of
your component's modules

00:02:35.010 --> 00:02:35.790
and services.

00:02:35.790 --> 00:02:38.100
Once identified, you can
then refactor your code

00:02:38.100 --> 00:02:39.150
to break the loop.

00:02:39.150 --> 00:02:41.080
For additional
details and examples,

00:02:41.080 --> 00:02:42.780
check out the dependency
injection guide

00:02:42.780 --> 00:02:46.040
in the official
Angular documentation.

